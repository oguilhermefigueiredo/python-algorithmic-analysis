# Computer Science and Programming in Python

## Branch

Branching in programming is when you implement different paths with different
blocks of code in according to the veracity of a conditional statement that is
up to the computer evalutate and judge which one is the appropriate and which
isn't. 

It's like a *decision*, as a lot of blogs and courses say, but it isn't what
actually happens: you, as the programmer, needs to predict previously the
group of the potencial possibilities, declare the correspondent behaviors 
as well as describe the relative values or context occasions in a way that the
machine can return a boolean value (true or false) and *decide* a path.

This concept makes more sense when you already know and use conditional
statements, such as ``if, else, elif, else if`` and so forth.

## Iteration

Iteration is about repetition, and repetition is about **loops**. That's a key
concept that surrounds all the topics and areas which includes any incipient or
complex use of Mathematics, because without iterations, algorithms couldn't
exist. 

Even to calculate what the result of ``2x2`` is you need to follow an algorithm
and expect the end of it to receive the desired output, and if it's not the
correct, you can iterate again and again until the value be ``4``. But when the
value is encoutered, you need to stop, so a condition is needed to interrupt the
repetition flow, or you would change the value in scope of your necessity.

- You can choose among two different types of famous loops: ``for`` and ``while``.

You'll use while when you have just a few conditions where your block of code
should stop or when you cannot anticipate the inputs from unknown origins. Like
in a game, where the character needs to go to the right and scape from the
forest, if the player continues to go to the left, he'll remain in the forest
until he decide to go the right, but how can you predict when that will happen?
That's the usefullness of while loops.

A Fibonacci sequence can be calculated with a for loop, being ``n`` the number
of iterations needed to achieve the result. In that case, you know how many
times you're supposed to repeat, so you can specify through a for loop that ``n``
is the limit of the iteration. But it's not needed the quantitative exactitude
to iterate over a defined variable, object, string or array, as all of them have
items inside that delimits the length of the entity, being possible to iterate
over a buch of numbers inside an array without knowing how many values are there.

## Procedures
<!--Functions-->

## Aliasing
<!--Structure-->
Treating elements inside a list as variables can bring up to you a lot of
different possibilities of action that, otherwise, you would have to do them
one by one, each time you want to handle an item of a list.

Aliasing allows you to point out to values which are piled in a collection
and give them a simbolic name, becoming new variables accessible outside its
original block of code.

## Mutability 

Some data types are not elegible of new assignments or alterations of its
contents. In the other hand, some of them are.

In Python, strings are immutable, meaning that once declared, you cannot just
add or change its characters without some restrictions, limitations or side
effects. But lists in Python can be changed from edge to side, being different
the properties of these asymmetric data types because of the different contexts
and usability that each of them was meant to be applied to.

Being aware of these disparities of language features and parallelism of 
computing laws is primordial when dealing with complex problems involving data, 
mathematical operations, as well as any kind of task and functionality which a 
software engineer should solve and implement. If you don't know them, these
responsabilities will come so difficult that months will be necessary to reach
a solution, being that solution probably the worst among all the other possible
ones.

## Recursion

